<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Separación de Parches Morados — HSV (Brython)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- Brython -->
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython_stdlib.js"></script>

<style>
body{
  margin:0;
  font-family:system-ui;
  background:#020617;
  color:#e5e7eb;
}
.wrap{max-width:1200px;margin:0 auto;padding:16px}
h1{font-size:1.4rem;margin-bottom:8px}
.card{
  background:#020617;
  border-radius:14px;
  border:1px solid rgba(148,163,184,.4);
  padding:14px;
  box-shadow:0 10px 30px rgba(0,0,0,.6);
  margin-top:12px;
}
.row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
input[type=file]{display:none}
.btn{
  padding:9px 14px;
  border-radius:10px;
  border:1px solid rgba(148,163,184,.7);
  background:#020617;
  color:#e5e7eb;
  cursor:pointer;
  font-size:.95rem;
}
.btn.primary{border-color:#38bdf8}
.btn.ok{border-color:#22c55e}
.status{color:#a5b4fc;font-size:.9rem;margin-top:6px}
#srcCanvas{display:none}
#preview{
  max-width:100%;
  border-radius:10px;
  margin-top:10px;
  border:1px solid rgba(148,163,184,.3);
}
#patches{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
.patch{border-radius:8px;border:1px solid rgba(148,163,184,.4);overflow:hidden;background:#0b1120}
.patch canvas{display:block;max-width:150px;height:auto}
.badge{padding:2px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.7);font-size:.8rem;color:#a5b4fc;margin-left:4px}
.slider-box{margin:6px 0;color:#cbd5e1;font-size:.85rem}
</style>
</head>

<body onload="brython()">

<div class="wrap">

<h1>Separación Automática de Parches Morados — HSV</h1>
<p>Detector avanzado de morados basado en HSV, con auto-relajación y extracción de parches.</p>

<!-- PANEL PRINCIPAL -->
<div class="card">
  <div class="row">
    <label class="btn primary">
      <input id="fileInput" type="file" accept="image/*">
      Subir imagen
    </label>
    <button id="btnProcess" class="btn">Procesar morados</button>
    <button id="btnDownload" class="btn ok">Descargar mosaico</button>
    <span id="info" class="badge">0 parches</span>
  </div>
  <div id="status" class="status">Estado: esperando imagen…</div>
  <img id="preview" alt="Vista previa" />
</div>

<!-- AJUSTE DE UMBRALES -->
<div class="card">
  <h3>Ajuste fino (opcional)</h3>

  <div class="slider-box">
    Saturación mínima:
    <input id="sMin" type="range" min="0" max="100" value="25"> <span id="sMinVal">25%</span>
  </div>

  <div class="slider-box">
    Valor mínimo:
    <input id="vMin" type="range" min="0" max="100" value="25"> <span id="vMinVal">25%</span>
  </div>

  <div class="slider-box">
    Área mínima del parche:
    <input id="minArea" type="range" min="20" max="2000" value="80"> <span id="minAreaVal">80</span>
  </div>
</div>

<!-- RESULTADOS -->
<div class="card">
  <h2 style="font-size:1.05rem;margin-top:0">Parches morados detectados</h2>
  <div id="patches"></div>
</div>

<!-- hidden canvas -->
<canvas id="srcCanvas"></canvas>

</div>

<!-- ================================= BRYTHON ================================= -->
<script type="text/python">
from browser import document, html, window
import math

# ======================= REFERENCIAS ===========================
file_input = document["fileInput"]
btn_process = document["btnProcess"]
btn_download = document["btnDownload"]
preview_el = document["preview"]
status_el = document["status"]
patches_el = document["patches"]
info_el = document["info"]

src_canvas = document["srcCanvas"]
src_ctx = src_canvas.getContext("2d")

# sliders
sMin = document["sMin"]
vMin = document["vMin"]
minArea = document["minArea"]

document["sMinVal"].text = sMin.value + "%"
document["vMinVal"].text = vMin.value + "%"
document["minAreaVal"].text = minArea.value

for s, label, suf in [
    (sMin,"sMinVal","%"),
    (vMin,"vMinVal","%"),
    (minArea,"minAreaVal","")
]:
    def bind_slider(ev, s=s, label=label, suf=suf):
        document[label].text = s.value + suf
    s.bind("input", bind_slider)

current_img = None
image_ready = False

def set_status(t):
    status_el.text = f"Estado: {t}"

# ======================= CARGA DE IMAGEN =======================
def on_file(ev):
    global current_img, image_ready
    files = ev.target.files
    if not files:
        set_status("No se seleccionó archivo.")
        return
    f = files[0]
    reader = window.FileReader.new()

    def onload(e):
        img = html.IMG()
        def onimg(_):
            global current_img, image_ready
            current_img = img
            image_ready = True

            preview_el.src = img.src
            w, h = img.naturalWidth, img.naturalHeight
            src_canvas.width, src_canvas.height = w, h
            src_ctx.drawImage(img, 0, 0)
            set_status(f"Imagen cargada ({w}×{h}).")
        img.bind("load", onimg)
        img.src = e.target.result

    reader.bind("load", onload)
    reader.readAsDataURL(f)
    set_status("Cargando imagen…")

file_input.bind("change", on_file)


# ======================= CONVERSIÓN HSV ========================
def rgb_to_hsv(r,g,b):
    r2, g2, b2 = r/255, g/255, b/255
    mx = max(r2, g2, b2)
    mn = min(r2, g2, b2)
    diff = mx - mn

    # Hue
    if diff == 0:
        h = 0
    elif mx == r2:
        h = (60*((g2 - b2)/diff) + 360) % 360
    elif mx == g2:
        h = (60*((b2 - r2)/diff) + 120) % 360
    else:
        h = (60*((r2 - g2)/diff) + 240) % 360

    # Saturation
    s = 0 if mx == 0 else diff/mx

    # Value
    v = mx

    return h, s, v


# ======================= DETECTOR DE MORADO HSV =======================
def is_purple(r,g,b):
    h,s,v = rgb_to_hsv(r,g,b)

    # rango fino de morados
    if not (250 <= h <= 310):
        return False

    if s < (int(sMin.value)/100): return False
    if v < (int(vMin.value)/100): return False

    return True


# ======================= PROCESAR MORADOS =======================
def process(ev):
    global image_ready

    if not image_ready:
        window.alert("Primero sube una imagen.")
        return

    patches_el.clear()

    w, h = src_canvas.width, src_canvas.height
    data = src_ctx.getImageData(0,0,w,h).data

    mask = [0]*(w*h)
    count = 0

    # Primera pasada
    for y in range(h):
        for x in range(w):
            idx = y*w + x
            p = idx*4
            r = data[p]; g = data[p+1]; b = data[p+2]
            if is_purple(r,g,b):
                mask[idx]=1
                count+=1

    # Si no hay morados, hacer detección relajada
    if count == 0:
        set_status("No detecta en rango primario. Activando detección relajada...")
        def is_purple_relaxed(r,g,b):
            h,s,v = rgb_to_hsv(r,g,b)
            if not (230 <= h <= 330): return False
            if s < 0.15: return False
            if v < 0.20: return False
            return True

        for y in range(h):
            for x in range(w):
                idx = y*w + x
                p = idx*4
                r = data[p]; g=data[p+1]; b=data[p+2]
                if is_purple_relaxed(r,g,b):
                    mask[idx]=1
                    count += 1

        if count == 0:
            info_el.text = "0 parches"
            set_status("No se detectaron parches morados (ni con rango relajado).")
            return

    set_status(f"Píxeles morados detectados: {count}")

    # BFS para componentes
    visited=[0]*(w*h)
    dirs=[(1,0),(-1,0),(0,1),(0,-1)]
    patches=[]

    for y in range(h):
        for x in range(w):
            idx0 = y*w+x
            if mask[idx0]==0 or visited[idx0]==1: continue

            q=[(x,y)]
            visited[idx0]=1
            minx=maxx=x
            miny=maxy=y
            area=0

            while q:
                cx,cy = q.pop()
                area+=1
                if cx<minx: minx=cx
                if cx>maxx: maxx=cx
                if cy<miny: miny=cy
                if cy>maxy: maxy=cy

                for dx,dy in dirs:
                    nx,ny = cx+dx, cy+dy
                    if 0<=nx<w and 0<=ny<h:
                        idxn = ny*w+nx
                        if mask[idxn]==1 and visited[idxn]==0:
                            visited[idxn]=1
                            q.append((nx,ny))

            if area >= int(minArea.value):
                patches.append((minx,miny,maxx,maxy,area))

    if not patches:
        info_el.text="0 parches"
        set_status("No se detectaron parches morados suficientemente grandes.")
        return

    patches.sort(key=lambda p:(p[1],p[0]))

    # Mostrar
    for i,(minx,miny,maxx,maxy,area) in enumerate(patches,start=1):
        pw=maxx-minx+1
        ph=maxy-miny+1
        c = html.CANVAS()
        c.width=pw; c.height=ph
        ctx=c.getContext("2d")
        ctx.drawImage(src_canvas,minx,miny,pw,ph,0,0,pw,ph)

        box=html.DIV(Class="patch")
        box<=c
        box<=html.DIV(f"#{i} — {pw}×{ph}, área≈{area}",
                      style={"font-size":"0.75rem","color":"#9ca3af","padding":"2px 6px"})
        patches_el<=box

    info_el.text=f"{len(patches)} parches"
    set_status(f"Detectados {len(patches)} parches.")
    document['patches_list'] = patches


btn_process.bind("click", process)


# ======================= DESCARGAR MOSAICO =======================
def download(ev):
    patches = document.get('patches_list', None)
    if not patches:
        window.alert("Procesa primero los parches.")
        return

    wsum = 0
    rows=[]
    row=[]
    max_h=0

    for i,p in enumerate(patches):
        minx,miny,maxx,maxy,area = p
        pw=maxx-minx+1
        ph=maxy-miny+1
        row.append((minx,miny,pw,ph))
        if ph>max_h: max_h=ph
        if (i+1)%4==0:
            rows.append((row,max_h))
            row=[]
            max_h=0
    if row:
        rows.append((row,max_h))

    total_w = 0
    total_h = 0
    for (r,hh) in rows:
        rw=sum([pw for _,_,pw,_ in r])
        if rw>total_w: total_w=rw
        total_h += hh

    out = html.CANVAS()
    out.width = total_w
    out.height= total_h
    octx = out.getContext("2d")

    yoff=0
    for (r,hh) in rows:
        xoff=0
        for (minx,miny,pw,ph) in r:
            octx.drawImage(src_canvas,minx,miny,pw,ph,xoff,yoff,pw,ph)
            xoff += pw
        yoff += hh

    a = html.A()
    a.download = "mosaico_morados.png"
    a.href = out.toDataURL("image/png")
    a.click()

btn_download.bind("click", download)

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Mosaico 16 parches lila – JavaScript puro</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  body{
    font-family:system-ui,Arial;
    background:#0b1220;
    color:#e5e7eb;
    margin:0;padding:20px;
  }
  h1{font-size:1.4rem;margin-bottom:12px}
  .card{
    background:#0f172a;
    padding:15px;
    border-radius:14px;
    border:1px solid rgba(148,163,184,.4);
    margin-bottom:20px;
  }
  button,input{
    padding:8px 14px;
    border-radius:10px;
    border:1px solid #38bdf8;
    background:#0f172a;
    color:white;
    cursor:pointer;
    margin-right:8px;
  }
  img{
    max-width:100%;
    border-radius:10px;
    border:1px solid rgba(148,163,184,.3);
    margin-top:10px;
  }
</style>
</head>
<body>

<h1>Extracción de 16 parches morado-lila → Mosaico 4×4 (JavaScript puro)</h1>

<div class="card">
  <input id="fileInput" type="file" accept="image/*">
  <button onclick="processImage()">Procesar (buscar 16)</button>
  <button onclick="exportMosaic()">Descargar mosaico</button>
  <div id="status" style="margin-top:10px;color:#a5b4fc;">Estado: esperando imagen…</div>
</div>

<div class="card">
  <h2>Original</h2>
  <img id="original">
</div>

<div class="card">
  <h2>Mosaico 4×4</h2>
  <canvas id="mosaicCanvas"></canvas>
</div>

<script>
// --------------------------------------------------------------
//  UTILIDADES HSV
// --------------------------------------------------------------
function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    let max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h,s,v=max;
    let d=max-min;
    s=max===0?0:d/max;

    if(max===min){h=0;}
    else{
        switch(max){
            case r:h=(g-b)/d+(g<b?6:0);break;
            case g:h=(b-r)/d+2;break;
            case b:h=(r-g)/d+4;break;
        }
        h/=6;
    }
    return [h*360,s*100,v*100];
}

// --------------------------------------------------------------
//  CARGAR IMAGEN
// --------------------------------------------------------------
let originalImg=null;
let loadedCanvas=null;

document.getElementById("fileInput").onchange=e=>{
    if(!e.target.files.length)return;
    const file=e.target.files[0];
    const reader=new FileReader();
    reader.onload=function(ev){
        originalImg=new Image();
        originalImg.onload=function(){
            document.getElementById("original").src=originalImg.src;

            loadedCanvas=document.createElement("canvas");
            loadedCanvas.width=originalImg.width;
            loadedCanvas.height=originalImg.height;
            loadedCanvas.getContext("2d").drawImage(originalImg,0,0);
        };
        originalImg.src=ev.target.result;
    }
    reader.readAsDataURL(file);
};

// --------------------------------------------------------------
//  DETECTAR PARCHES MORADO–LILA (HSV)
// --------------------------------------------------------------
function detectLilacPatches(){
    const ctx=loadedCanvas.getContext("2d");
    const {width:w,height:h}=loadedCanvas;
    const data=ctx.getImageData(0,0,w,h);
    const pix=data.data;

    const mask=new Array(w*h).fill(0);

    for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
            const i=(y*w+x)*4;
            const [H,S,V]=rgbToHsv(pix[i],pix[i+1],pix[i+2]);

            // Rango morado-lila
            let ok = (
              (H>=235 && H<=335) &&
              S>=10 && V>=10
            );

            if(ok) mask[y*w+x]=1;
        }
    }

    return mask;
}

// --------------------------------------------------------------
//  BFS PARA COMPONENTES CONEXOS
// --------------------------------------------------------------
function labelComponents(mask,w,h){
    const visited=new Array(w*h).fill(false);
    let comps=[];
    let dirs=[[1,0],[-1,0],[0,1],[0,-1]];

    for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
            const idx=y*w+x;
            if(mask[idx] && !visited[idx]){
                let q=[[x,y]];
                visited[idx]=true;

                let minx=x,maxx=x,miny=y,maxy=y;
                let list=[[x,y]];

                while(q.length){
                    let [cx,cy]=q.pop();
                    for(let [dx,dy] of dirs){
                        let nx=cx+dx, ny=cy+dy;
                        if(nx>=0&&ny>=0&&nx<w&&ny<h){
                            const nidx=ny*w+nx;
                            if(mask[nidx] && !visited[nidx]){
                                visited[nidx]=true;
                                q.push([nx,ny]);
                                list.push([nx,ny]);
                                minx=Math.min(minx,nx);
                                maxx=Math.max(maxx,nx);
                                miny=Math.min(miny,ny);
                                maxy=Math.max(maxy,ny);
                            }
                        }
                    }
                }
                comps.push({minx,maxx,miny,maxy, pixels:list});
            }
        }
    }
    return comps;
}

// --------------------------------------------------------------
//  PROCESAR
// --------------------------------------------------------------
function processImage(){
    if(!loadedCanvas){
        document.getElementById("status").innerText="Sube primero un JPG.";
        return;
    }

    const w=loadedCanvas.width;
    const h=loadedCanvas.height;

    const mask=detectLilacPatches();
    let comps=labelComponents(mask,w,h);

    // Filtrar por tamaños razonables
    comps=comps.filter(c=>{
        const bw=c.maxx-c.minx;
        const bh=c.maxy-c.miny;
        const ar=bw/bh;
        return ar>1.0 && ar<5.0 && bw>20 && bh>10;
    });

    // Ordenar por fila/columna
    comps.sort((a,b)=> (a.miny-b.miny) || (a.minx-b.minx));

    const ctx=loadedCanvas.getContext("2d");

    // Recortar parches
    let crops=[];
    for(let c of comps){
        let bw=c.maxx-c.minx+1;
        let bh=c.maxy-c.miny+1;
        let cv=document.createElement("canvas");
        cv.width=bw; cv.height=bh;
        cv.getContext("2d").drawImage(loadedCanvas,c.minx,c.miny,bw,bh,0,0,bw,bh);
        crops.push(cv);
    }

    // Solo 16
    crops=crops.slice(0,16);

    document.getElementById("status").innerText =
        "Detectados: "+crops.length+" parches";

    drawMosaic(crops);
}

// --------------------------------------------------------------
//  MOSAICO 4×4
// --------------------------------------------------------------
function drawMosaic(crops){
    const canvas=document.getElementById("mosaicCanvas");
    if(crops.length===0){
        canvas.width=600; canvas.height=300;
        return;
    }

    // Normalizar tamaño: usar mediana
    let ws=crops.map(c=>c.width);
    let hs=crops.map(c=>c.height);
    let tw=ws.sort((a,b)=>a-b)[Math.floor(ws.length/2)];
    let th=hs.sort((a,b)=>a-b)[Math.floor(hs.length/2)];

    const margin=12;
    const rows=4, cols=4;
    const W=cols*tw+(cols+1)*margin;
    const H=rows*th+(rows+1)*margin;
    canvas.width=W; canvas.height=H;

    const ctx=canvas.getContext("2d");
    ctx.fillStyle="white";
    ctx.fillRect(0,0,W,H);

    let i=0;
    for(let r=0;r<4;r++){
        for(let c=0;c<4;c++){
            if(i>=crops.length)break;
            let x=margin + c*(tw+margin);
            let y=margin + r*(th+margin);

            ctx.drawImage(crops[i],0,0,crops[i].width,crops[i].height,x,y,tw,th);
            i++;
        }
    }
}

// --------------------------------------------------------------
//  DESCARGAR
// --------------------------------------------------------------
function exportMosaic(){
    const canvas=document.getElementById("mosaicCanvas");
    const link=document.createElement("a");
    link.download="mosaico_16_lila.png";
    link.href=canvas.toDataURL("image/png");
    link.click();
}
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Separación de parches morados — Brython</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Brython desde CDN -->
  <script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython_stdlib.js"></script>
  <style>
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
      background:#020617;
      color:#e5e7eb;
    }
    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:16px;
    }
    h1{font-size:1.4rem;margin-bottom:8px}
    p{color:#9ca3af;font-size:.95rem}
    .card{
      background:#020617;
      border-radius:14px;
      border:1px solid rgba(148,163,184,.4);
      padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.6);
      margin-top:12px;
    }
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    input[type=file]{display:none}
    .btn{
      padding:9px 14px;
      border-radius:10px;
      border:1px solid rgba(148,163,184,.7);
      background:#020617;
      color:#e5e7eb;
      cursor:pointer;
      font-size:.95rem;
    }
    .btn.primary{border-color:#38bdf8}
    .btn[disabled]{
      opacity:0.5;
      cursor:not-allowed;
    }
    .status{color:#a5b4fc;font-size:.9rem;margin-top:6px}
    #srcCanvas{display:none}
    #preview{
      max-width:100%;
      border-radius:10px;
      margin-top:10px;
      border:1px solid rgba(148,163,184,.3);
    }
    #patches{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    .patch{
      border-radius:8px;
      border:1px solid rgba(148,163,184,.4);
      overflow:hidden;
      background:#0b1120;
    }
    .patch canvas{
      display:block;
      max-width:150px;
      height:auto;
    }
    .badge{
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(148,163,184,.7);
      font-size:.8rem;
      color:#a5b4fc;
      margin-left:4px;
    }
    #mosaicCanvas{
      display:none;
      margin-top:10px;
      border-radius:10px;
      border:1px solid rgba(148,163,184,.4);
      max-width:100%;
    }
  </style>
</head>
<body onload="brython()">
  <div class="wrap">
    <h1>Separación de parches morados — Brython</h1>
    <p>
      Sube una imagen con parches lila/morados. El programa detecta regiones de color
      morado usando un criterio tipo HSV + reglas sobre R/G/B, agrupa los píxeles
      contiguos y genera un mosaico con cada parche separado, además de un mosaico
      general descargable en PNG.
    </p>

    <div class="card">
      <div class="row">
        <label class="btn primary">
          <input id="fileInput" type="file" accept="image/*">
          Subir imagen
        </label>
        <button id="btnProcess" class="btn">Procesar morados</button>
        <span id="info" class="badge">0 parches</span>
      </div>
      <div id="status" class="status">Estado: esperando imagen…</div>
      <img id="preview" alt="Vista previa" />
    </div>

    <div class="card">
      <h2 style="font-size:1.05rem;margin-top:0;margin-bottom:4px">Parches morados detectados</h2>
      <div id="patches"></div>

      <div class="row" style="margin-top:10px">
        <button id="btnDownloadMosaic" class="btn" disabled>Descargar mosaico (PNG)</button>
      </div>
      <canvas id="mosaicCanvas"></canvas>
    </div>

    <!-- Canvas oculto para procesar -->
    <canvas id="srcCanvas"></canvas>
  </div>

  <!-- Código Python (Brython) -->
  <script type="text/python">
from browser import document, html, window
import math

file_input = document["fileInput"]
btn_process = document["btnProcess"]
status_el = document["status"]
preview_el = document["preview"]
patches_el = document["patches"]
info_el = document["info"]
src_canvas = document["srcCanvas"]
src_ctx = src_canvas.getContext("2d")
mosaic_canvas = document["mosaicCanvas"]
btn_download = document["btnDownloadMosaic"]

current_img = None   # referencia al objeto IMG cargado
image_ready = False

def set_status(text):
    status_el.text = f"Estado: {text}"

def on_file_change(ev):
    global current_img, image_ready
    files = ev.target.files
    if not files:
        set_status("No se seleccionó archivo.")
        return
    f = files[0]
    reader = window.FileReader.new()

    def onload(e):
        nonlocal f
        img = html.IMG()
        def on_img_load(ev2):
            global current_img, image_ready
            current_img = img
            image_ready = True
            preview_el.src = img.src
            w = img.naturalWidth
            h = img.naturalHeight
            src_canvas.width = w
            src_canvas.height = h
            src_ctx.drawImage(img, 0, 0)
            set_status(f"Imagen cargada ({w}×{h}). Listo para procesar morados.")
            btn_download.disabled = True
            mosaic_canvas.style.display = "none"
        img.bind("load", on_img_load)
        img.src = e.target.result

    reader.bind("load", onload)
    reader.readAsDataURL(f)
    set_status("Cargando imagen…")

file_input.bind("change", on_file_change)

def rgb_to_hsv(r, g, b):
    """Conversión simple RGB → HSV (0-360, 0-1, 0-1)."""
    r_f = r / 255.0
    g_f = g / 255.0
    b_f = b / 255.0

    mx = max(r_f, g_f, b_f)
    mn = min(r_f, g_f, b_f)
    diff = mx - mn

    # Hue
    if diff == 0:
        h = 0.0
    elif mx == r_f:
        h = (60 * ((g_f - b_f) / diff) + 360) % 360
    elif mx == g_f:
        h = (60 * ((b_f - r_f) / diff) + 120) % 360
    else:
        h = (60 * ((r_f - g_f) / diff) + 240) % 360

    # Saturation
    s = 0.0 if mx == 0 else diff / mx
    v = mx
    return h, s, v

def is_purple(r, g, b):
    """
    Criterio robusto de lila/morado.
    Portado de la lógica que usábamos en JS (HSV + heurísticas RGB).
    Ajustado a las típicas telas/parches lila-morados.
    """
    h, s, v = rgb_to_hsv(r, g, b)

    # 1) Hue entre 255° y 335° (zona violeta-magenta), con algo de saturación y brillo
    if (255 <= h <= 335) and s > 0.12 and v > 0.12:
        return True

    # 2) Regla RGB: saturación moderada, rojo > azul > verde, verde algo más bajo
    if s > 0.10 and r > b and g < r and b > g * 0.9:
        return True

    # 3) Regla de refuerzo: R y B altos, G más bajo, suma R+B fuerte
    if r > 80 and b > 80 and (r + b) > 220 and r > g * 1.05:
        return True

    return False

def process_purple(ev):
    global image_ready
    if not image_ready:
        window.alert("Primero sube una imagen.")
        return

    w = src_canvas.width
    h = src_canvas.height
    if w == 0 or h == 0:
        set_status("Canvas vacío.")
        return

    set_status("Procesando morados… (esto puede tardar unos segundos)")
    patches_el.clear()
    info_el.text = "0 parches"
    btn_download.disabled = True
    mosaic_canvas.style.display = "none"

    img_data = src_ctx.getImageData(0, 0, w, h)
    data = img_data.data

    # Máscara binaria: 1 si morado
    mask = [0] * (w * h)
    for y in range(h):
        base = y * w
        for x in range(w):
            idx = base + x
            p = idx * 4
            r = data[p]
            g = data[p + 1]
            b = data[p + 2]
            if is_purple(r, g, b):
                mask[idx] = 1

    # Componentes conectados 4-neighbors
    visited = [0] * (w * h)
    patches = []
    dirs = [(1,0),(-1,0),(0,1),(0,-1)]

    for y in range(h):
        for x in range(w):
            idx0 = y*w + x
            if mask[idx0] == 0 or visited[idx0] == 1:
                continue
            queue = [(x, y)]
            visited[idx0] = 1
            minx = x; maxx = x
            miny = y; maxy = y
            area = 0

            while queue:
                cx, cy = queue.pop()
                area += 1
                if cx < minx: minx = cx
                if cx > maxx: maxx = cx
                if cy < miny: miny = cy
                if cy > maxy: maxy = cy

                for dx, dy in dirs:
                    nx = cx + dx
                    ny = cy + dy
                    if 0 <= nx < w and 0 <= ny < h:
                        idxn = ny*w + nx
                        if mask[idxn] == 1 and visited[idxn] == 0:
                            visited[idxn] = 1
                            queue.append((nx, ny))

            # Filtrar componentes demasiado pequeños
            if area < 80:
                continue
            patches.append((minx, miny, maxx, maxy, area))

    if not patches:
        set_status("No se detectaron parches morados con el criterio actual.")
        info_el.text = "0 parches"
        return

    # Ordenar por posición: primero arriba-abajo, luego izquierda-derecha
    patches_sorted = sorted(patches, key=lambda p: (p[1], p[0]))

    patch_canvases = []

    # Crear un canvas por parche y mostrarlo
    for i, (minx, miny, maxx, maxy, area) in enumerate(patches_sorted, start=1):
        pw = maxx - minx + 1
        ph = maxy - miny + 1
        c = html.CANVAS()
        c.width = pw
        c.height = ph
        ctx = c.getContext("2d")
        ctx.drawImage(src_canvas, minx, miny, pw, ph, 0, 0, pw, ph)

        cont = html.DIV(Class="patch")
        cont <= c
        label = html.DIV(
            f"#{i} — {pw}×{ph}, área≈{area}",
            style={
                "font-size": "0.75rem",
                "color": "#9ca3af",
                "padding": "2px 6px"
            }
        )
        cont <= label
        patches_el <= cont
        patch_canvases.append(c)

    info_el.text = f"{len(patches_sorted)} parches"
    set_status(f"Listo. Detectados {len(patches_sorted)} parches morados.")

    # Crear mosaico vertical (una sola imagen apilando todos los parches)
    if patch_canvases:
        max_w = max(c.width for c in patch_canvases)
        total_h = sum(c.height for c in patch_canvases)
        mosaic_canvas.width = max_w
        mosaic_canvas.height = total_h
        mctx = mosaic_canvas.getContext("2d")
        y_off = 0
        for c in patch_canvases:
            mctx.drawImage(c, 0, y_off)
            y_off += c.height
        mosaic_canvas.style.display = "block"
        btn_download.disabled = False

def download_mosaic(ev):
    # Descarga el contenido del canvas mosaico como PNG
    if mosaic_canvas.width == 0 or mosaic_canvas.height == 0:
        window.alert("No hay mosaico generado todavía.")
        return
    url = mosaic_canvas.toDataURL("image/png")
    a = html.A("download")
    a.attrs["href"] = url
    a.attrs["download"] = "mosaico_morados.png"
    document <= a
    a.click()
    a.remove()

btn_process.bind("click", process_purple)
btn_download.bind("click", download_mosaic)
  </script>
</body>
</html>

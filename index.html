<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Extracción de 16 cuadrados lila – Brython</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<!-- Brython -->
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/brython@3.12.2/brython_stdlib.js"></script>

<style>
body{
  margin:0;
  font-family:system-ui;
  background:#0b1220;
  color:#e5e7eb;
}
.wrap{max-width:1200px;margin:0 auto;padding:16px}
h1{font-size:1.4rem;margin-bottom:8px}
.card{
  background:#0f172a;
  border-radius:14px;
  border:1px solid rgba(148,163,184,.4);
  padding:14px;
  margin-top:12px;
}
.row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
input[type=file]{display:none}
.btn{
  padding:8px 14px;
  border-radius:10px;
  border:1px solid rgba(148,163,184,.7);
  background:#0f172a;
  color:#e5e7eb;
  cursor:pointer;
  font-size:.95rem;
}
.btn.primary{border-color:#38bdf8}
.btn.warn{border-color:#fbbf24}
.btn.ok{border-color:#22c55e}
.status{color:#a5b4fc;font-size:.9rem;margin-top:6px}
.badge{padding:2px 8px;border-radius:999px;border:1px solid rgba(148,163,184,.7);font-size:.8rem;color:#a5b4fc;margin-left:4px}

img.preview{
  max-width:100%;
  border-radius:10px;
  margin-top:10px;
  border:1px solid rgba(148,163,184,.3);
}

/* Canvases ocultos (procesamiento) */
#srcCanvas, #detCanvas, #mosaicCanvas{
  display:none;
}
</style>
</head>

<body onload="brython()">

<div class="wrap">

  <h1>Extracción de 16 cuadrados lila – Consumertec</h1>
  <p>Sube la foto de la manta, detecta los parches lila y genera un mosaico 4×4 descargable.</p>

  <!-- PANEL DE CONTROL -->
  <div class="card">
    <div class="row">
      <label class="btn primary">
        <input id="fileInput" type="file" accept="image/*">
        Subir JPG
      </label>
      <button id="btnProcess" class="btn warn">Procesar (buscar 16)</button>
      <button id="btnDownload" class="btn ok">Descargar mosaico</button>
      <span id="info" class="badge">0 parches</span>
    </div>
    <div id="status" class="status">Estado: esperando imagen…</div>
  </div>

  <!-- VISTAS -->
  <div class="card">
    <h2 style="font-size:1.05rem;margin-top:0">Original</h2>
    <img id="previewOrig" class="preview" alt="Imagen original" />
  </div>

  <div class="card">
    <h2 style="font-size:1.05rem;margin-top:0">Mosaico 4×4 (hasta 16 parches lila)</h2>
    <img id="previewMosaic" class="preview" alt="Mosaico 4×4" />
  </div>

  <!-- CANVAS OCULTOS -->
  <canvas id="srcCanvas"></canvas>
  <canvas id="detCanvas"></canvas>
  <canvas id="mosaicCanvas"></canvas>

</div>

<!-- ======================== BRYTHON PYTHON ======================== -->
<script type="text/python">
from browser import document, html, window

# ---------- Referencias DOM ----------
file_input    = document["fileInput"]
btn_process   = document["btnProcess"]
btn_download  = document["btnDownload"]
status_el     = document["status"]
info_el       = document["info"]
preview_orig  = document["previewOrig"]
preview_mos   = document["previewMosaic"]

src_canvas    = document["srcCanvas"]   # tamaño original
src_ctx       = src_canvas.getContext("2d")
det_canvas    = document["detCanvas"]   # imagen redimensionada para detección
det_ctx       = det_canvas.getContext("2d")
mos_canvas    = document["mosaicCanvas"]
mos_ctx       = mos_canvas.getContext("2d")

image_ready   = False
scale_factor  = 1.0   # original → detección
image_name    = "imagen"


def set_status(msg):
    status_el.text = "Estado: " + msg


# ---------- Conversión RGB → HSV ----------
def rgb_to_hsv(r, g, b):
    r2 = r / 255.0
    g2 = g / 255.0
    b2 = b / 255.0
    mx = max(r2, g2, b2)
    mn = min(r2, g2, b2)
    diff = mx - mn

    if diff == 0:
        h = 0.0
    elif mx == r2:
        h = (60.0 * ((g2 - b2) / diff) + 360.0) % 360.0
    elif mx == g2:
        h = (60.0 * ((b2 - r2) / diff) + 120.0) % 360.0
    else:
        h = (60.0 * ((r2 - g2) / diff) + 240.0) % 360.0

    s = 0.0 if mx == 0.0 else diff / mx
    v = mx
    return h / 360.0, s, v   # H normalizado 0–1


# ---------- Rangos Lila calibrados ----------
def is_lila_strict(h, s, v):
    # Rango estrecho, medido sobre DSC00442
    return (0.878 <= h <= 0.938) and (0.18 <= s <= 0.38) and (0.42 <= v <= 0.70)


def is_lila_relaxed(h, s, v):
    # Rango extendido para cambios de luz
    if (0.84 <= h <= 0.98) and (0.13 <= s <= 0.45) and (0.32 <= v <= 0.74):
        return True
    # Heurística extra: algo más azul que verde
    # (suave para no atrapar los círculos amarillos)
    return False


# ---------- Carga de imagen ----------
def on_file(ev):
    global image_ready, scale_factor, image_name
    files = ev.target.files
    if not files:
        set_status("No se seleccionó archivo.")
        return

    f = files[0]
    image_name = f.name or "imagen"
    reader = window.FileReader.new()

    def onload(e):
        img = html.IMG()

        def onimg(_ev):
            global image_ready, scale_factor
            image_ready = True

            # Mostrar vista previa
            preview_orig.src = img.src

            # Canvas original
            ow = img.naturalWidth
            oh = img.naturalHeight
            src_canvas.width  = ow
            src_canvas.height = oh
            src_ctx.drawImage(img, 0, 0)

            # Canvas de detección: ancho máximo 1600 px
            max_det_w = 1600
            if ow > max_det_w:
                scale_factor = max_det_w / float(ow)
            else:
                scale_factor = 1.0

            dw = int(ow * scale_factor)
            dh = int(oh * scale_factor)
            det_canvas.width  = dw
            det_canvas.height = dh
            det_ctx.drawImage(src_canvas, 0, 0, ow, oh, 0, 0, dw, dh)

            set_status(f"Imagen cargada ({ow}×{oh}). Escala detección: {scale_factor:.3f}")

        img.bind("load", onimg)
        img.src = e.target.result

    reader.bind("load", onload)
    reader.readAsDataURL(f)
    set_status("Cargando imagen…")


file_input.bind("change", on_file)


# ---------- Construir máscara lila ----------
def build_mask(mode="strict"):
    w = det_canvas.width
    h = det_canvas.height
    data = det_ctx.getImageData(0, 0, w, h).data
    total = w * h
    mask = [0] * total
    count = 0

    for y in range(h):
        base_y = y * w
        for x in range(w):
            idx = base_y + x
            p = idx * 4
            r = data[p]
            g = data[p + 1]
            b = data[p + 2]
            h_norm, s, v = rgb_to_hsv(r, g, b)

            if mode == "strict":
                ok = is_lila_strict(h_norm, s, v)
            else:
                ok = is_lila_strict(h_norm, s, v) or is_lila_relaxed(h_norm, s, v)

            if ok:
                mask[idx] = 1
                count += 1

    return mask, count, w, h


# ---------- BFS para buscar parches ----------
def find_patches(mask, w, h):
    visited = [0] * (w * h)
    patches = []
    total_area = w * h
    min_area = int(0.0001 * total_area)  # umbral mínimo de área

    for y in range(h):
        for x in range(w):
            idx0 = y * w + x
            if mask[idx0] == 0 or visited[idx0] == 1:
                continue

            # BFS
            q = [(x, y)]
            visited[idx0] = 1
            minx = maxx = x
            miny = maxy = y
            area = 0

            while q:
                cx, cy = q.pop()
                area += 1
                if cx < minx: minx = cx
                if cx > maxx: maxx = cx
                if cy < miny: miny = cy
                if cy > maxy: maxy = cy

                for dx, dy in ((1,0),(-1,0),(0,1),(0,-1)):
                    nx = cx + dx
                    ny = cy + dy
                    if 0 <= nx < w and 0 <= ny < h:
                        ni = ny * w + nx
                        if mask[ni] == 1 and visited[ni] == 0:
                            visited[ni] = 1
                            q.append((nx, ny))

            if area < min_area:
                continue

            bw = maxx - minx + 1
            bh = maxy - miny + 1
            if bh <= 0:
                continue
            ar = bw / float(bh)
            # Rectángulos razonables (ni líneas, ni bloques enormes)
            if ar < 0.7 or ar > 4.5:
                continue

            patches.append((minx, miny, maxx, maxy, area))

    return patches


# ---------- Conversión de parches a coordenadas originales ----------
def detection_to_original_bbox(patch, padding=8):
    minx, miny, maxx, maxy, area = patch
    ow = src_canvas.width
    oh = src_canvas.height
    dw = det_canvas.width
    dh = det_canvas.height

    # Factor original ← detección
    if dw == 0:
        return None
    inv = ow / float(dw)  # ~1/scale_factor

    x0 = int(max(0, (minx * inv) - padding))
    x1 = int(min(ow, (maxx + 1) * inv + padding))
    y0 = int(max(0, (miny * inv) - padding))
    y1 = int(min(oh, (maxy + 1) * inv + padding))

    if x1 <= x0 or y1 <= y0:
        return None
    return (x0, y0, x1, y1)


# ---------- Construir mosaico 4×4 ----------
def build_mosaic_from_patches(patches_src):
    n = len(patches_src)
    if n == 0:
        mos_canvas.width = 600
        mos_canvas.height = 400
        mos_ctx.fillStyle = "#111827"
        mos_ctx.fillRect(0, 0, mos_canvas.width, mos_canvas.height)
        return

    n_use = min(16, n)
    patches_src = patches_src[:n_use]

    widths = []
    heights = []
    for (x0, y0, x1, y1) in patches_src:
        widths.append(x1 - x0)
        heights.append(y1 - y0)

    widths.sort()
    heights.sort()
    mw = widths[len(widths)//2]
    mh = heights[len(heights)//2]

    # Tamaño base de cada celda
    cell_w = max(80, int(mw))
    cell_h = max(80, int(mh))

    rows = 4
    cols = 4
    margin = 12

    mos_w = cols * cell_w + (cols + 1) * margin
    mos_h = rows * cell_h + (rows + 1) * margin

    mos_canvas.width  = mos_w
    mos_canvas.height = mos_h

    mos_ctx.fillStyle = "#0b1120"
    mos_ctx.fillRect(0, 0, mos_w, mos_h)

    idx = 0
    for r in range(rows):
        for c in range(cols):
            if idx >= n_use:
                break
            x0, y0, x1, y1 = patches_src[idx]
            pw = x1 - x0
            ph = y1 - y0

            dest_x = margin + c * (cell_w + margin)
            dest_y = margin + r * (cell_h + margin)

            mos_ctx.drawImage(
                src_canvas,
                x0, y0, pw, ph,
                dest_x, dest_y, cell_w, cell_h
            )
            idx += 1


# ---------- Procesar imagen ----------
def process(ev):
    if not image_ready:
        window.alert("Primero sube un JPG.")
        return

    set_status("Procesando (rango estricto)…")
    mask, count, w, h = build_mask(mode="strict")
    patches = find_patches(mask, w, h)

    if len(patches) < 16:
        set_status(f"Encontrados {len(patches)} parches en estricto. Probando rango relajado…")
        mask_rel, count_rel, w, h = build_mask(mode="relaxed")
        patches = find_patches(mask_rel, w, h)

    if not patches:
        info_el.text = "0 parches"
        set_status("No se detectaron parches lila.")
        preview_mos.src = ""
        return

    # Ordenar por centro (fila, columna)
    patches.sort(key=lambda p: ( (p[1]+p[3])/2.0, (p[0]+p[2])/2.0 ))

    # Pasar a coordenadas del canvas original
    patches_src = []
    for patch in patches:
        bbox = detection_to_original_bbox(patch, padding=8)
        if bbox is not None:
            patches_src.append(bbox)

    if not patches_src:
        info_el.text = "0 parches"
        set_status("Los parches detectados no son válidos en el original.")
        preview_mos.src = ""
        return

    # Construir mosaico
    build_mosaic_from_patches(patches_src)

    # Vista previa del mosaico
    data_url = mos_canvas.toDataURL("image/png")
    preview_mos.src = data_url

    n_use = min(16, len(patches_src))
    info_el.text = f"{n_use} parches usados (de {len(patches_src)})"
    set_status("Mosaico 4×4 generado.")


btn_process.bind("click", process)


# ---------- Descargar mosaico ----------
def download(ev):
    if mos_canvas.width == 0 or mos_canvas.height == 0:
        window.alert("No hay mosaico para descargar. Pulsa primero ‘Procesar’.")
        return

    a = html.A()
    base = image_name.rsplit(".", 1)[0]
    a.download = f"{base}_mosaico_16_lila.png"
    a.href = mos_canvas.toDataURL("image/png")
    a.click()


btn_download.bind("click", download)
</script>

</body>
</html>
